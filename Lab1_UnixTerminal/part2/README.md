# x86-64 Assembly 

> "Nearing Machine Code Representation"

## Introduction/Motivation

Not so long ago (in a galaxy not so far away), programmers wrote most of their code in assembly. While programmers today primarily use higher level languages (Python, C, etc), it is not uncommon to debug the assembly of your code. These higher level languages afterall typically translate down to an assemble or assembly-like language. 

If you are interested in cybersecurity and reverse engineering, folks more frequently write and analyze assembly code. For high performance applications like [games](https://www.gamasutra.com/view/news/169946/CC_low_level_curriculum_Looking_at_optimized_assembly.php), programmers may write very optimized code using assembly to get things *just* right. If you are working in hardware or an embededd device, you might also do some assembly programming, as other languages environments are too bulky to support on a small device. Even web developers are using something called 'webassembly'. Hmm, the list is getting long here--I think the point is that learning assembly has quite some relevance! Let's dig in and get some practice.

In today's lab you are going to get some practice looking at assembly.

# Part 0 - Godbolt

I **strongly** recommend using the godbolt tool (https://godbolt.org/) to write and experiment with your C programs for this exercise.  The color mappings will help you see what is going on with the generated assembly. You **should** try using both godbolt and your compiler to generate assembly.

Here is an example of the Godbolt tool (and also shows part 4 of this lab)
<img src="./assembly.PNG">

# Part 1- Compiler Generated Assembly

Let us get some experience reading assembly code generated by the compiler (or godbolt)! It is actually kind of fun, you may learn some new instructions, and at the very least gain some intuition for what code the compiler is generating.

## Compiler generated assembly 1 - Swap

- Write a C program that swaps two integers(in the main body of code).
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as swap_int.s).
  - Use: `gcc -O0 -fno-builtin swap_int.c -S -o swap_int.s`
- Now modify your program to swap two long's.
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as swap_long.s).
  - Use: `gcc -O0 -fno-builtin swap_long.c -S -o swap_long.s`
- Compare each of the two assembly files using diff. See what changed.
- diff syntax
  - Use: `diff -y swap_int.s swap_long.s`
  
### Response/Observations

1. For swapping numbers, `movl` is used to move integer data (double word) around in swap_int.s, while `movq` is used to move long data (quad word) around in swap_long.s.
2. For storing data, we decrement the address relative to `%rbp` by 4 each time to store new data in swap_int.s (because double word is 4 bytes), while 8 each time in swap_long.s (because quad word is 8 bytes).
3. In swap_int.s, `%eax` is used to store temporary data (that is lower 32 bits of `%rax` because double word is 4 bytes), while `%rax`in swap_long.s (because quad word is 8 bytes).

## Compiler generated assembly 2 - Functions

- Write a C program that swaps two integers in a **function** (You may use today's slide as a reference)
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as swap.s).
  - Use: `gcc -O0 -fno-builtin  swap.c -S -o swap.s`
- Do the instructions use memory/registers in a different way?

### Response/Observations

The instructions utilize more registers to swap the integers.

In the swap function, the memory address of the two integers are stored in `%rdi` and `%rsi` espectively, and `movq` is used to move the address data around. Their addresses are also saved in `-24(%rbp)` and `-32(%rbp)`. In order to get the integer, its address is copied to `%rax` temporarily, and by using deference `(%rax)` we get the integer. Then we use `movl` to move the integers around by utilizing registers `%eax`, `%edx` and `-4(%rbp)`. 

## Compiler generated assembly 3 - Static Array
- Write a C program called array.c that has an array of 400 integers in the function of main.
  - Initialize some of the values to something (do not use a loop) (e.g. myArray[0]=72; myArray[70]=56; etc)
  	- Note that it is helpful to use 'weird' numbers so you can see where they jump out.
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as array.s).
  - Use: `gcc -O0 -fno-builtin  array.c -S -o array.s`
- How much are the offsets from the address?

### Response/Observations

The offsets are `4 * i`, where 4 is the size of an integer (double word, 4 bytes) and i is the index of an integer in the array. The ith integer in the array is stored in `-(1600 - 4 * i)(%rbp)`.

## Compiler generated assembly 4 - Dynamic Array 

- Write a C program called array2.c that has an array of 400 integers in the function of main that is dynamically allocated.
  - Initialize some of the values to something (do not use a loop) (e.g. myArray[66]=712; myArray[70]=536; etc)
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as array2.s).
  - Use: `gcc -O0 -fno-builtin  array2.c -S -o array2.s`
- Study the assembly and think about what is different from the static array.

### Response/Observations

1. In array.s, `subq  $1480, %rsp` is called before initilizing the array, while `subq  $16, %rsp` in array2.s.
2. In array.s, the ith integer is saved in the static array one by one by calling `-(1600 - 4 * i)(%rbp)` each time. However, in array2.s, the whole block of memomery for dynamic array is assigned before initializing its values by passing 1600 (4 * 400 bytes of integers) to `%edi` with `movl` and calling `malloc`. Then we get the memory address of (the first element in) the dynamic array from the return value of `malloc` which is stored i `%rax`, and save the address in `-8(%rbp)`. For initilizing the ith element of the dynamic array, the address of the array is moved back to `%rax` first, and by adding the value of i to `%rax` (`addq  $i, %rax`) we get the address of the ith element of the array, and finally we can save an integer (150 for example) at the ith position of the array by utilizing `movl` with dereference `movl  $150, (%rax)`.

## Compiler generated assembly 5 - Goto
The C programming language has a 'goto' command, search how to use it if you have not previously.

- Write a C program using the goto command and a label.
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as goto.s).
  - Use: `gcc -O0 -fno-builtin  goto.c -S -o goto.s`
- Observe what kind of jmp statement is inserted.

### Response/Observations

`jg` is inserted for jumping to the end of the code within the label when `-4(%rbp)` is greater than 9 (i.e., `i > 9`), and `jmp` is inserted after `jg` for jumping unconditionally to the beginning of the code within the label which prints the number i. 

## Compiler generated assembly 6 - For-loops
- Write a C program using a for-loop that counts to 5.
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as for.s).
  - Use: `gcc -O0 -fno-builtin  for.c -S -o for.s`
- Observe where the code goes for the condition statement (at the start or at the end?).

### Response/Observations

The code for the conditional statement `i < 5` (`cmpl  $4, -4(%rbp)`) goes at the end of the code for the for-loop. After initilizing the iterator, the code jumps directly to the code for the conditional statement by `jmp`, and determines whether to go inside the code for the loop or not by `jle` according to the result of `cmpl  $4, -4(%rbp)`.

## Compiler generated assembly 7 - Switch Statements

- Write a C program using a switch statement (Sample here)[https://www.tutorialspoint.com/cprogramming/switch_statement_in_c.htm].
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as switch.s).
  - Use: `gcc -O0 -fno-builtin switch.c -S -o switch.s`
- See what code a switch statement generates. Is it optimal?

### Response/Observations

It generates several code blocks with labels, each for the code for a case other than the first case. 

It first compares the value of the switched variable to the second to last cases by `cmpl`, and jumps to the code for the corresponding case by `je` if the value matches. If no case matches, it then does comparision between the first case and the variable, and jumps to the code for the default case by `jne` if they are not equal, otherwise it goes to the following code which is for the first case.

At the end of the code for each case, there is a `jmp` command that forces the code to jump unconditionally to whatever is after the code for the switch statement. 

## Compiler generated assembly 8 - Add Function

- Write a C program that calls an add function(long add(long a, long b).
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as add.s).
  - Use: `gcc -O0 -fno-builtin add.c -S -o add.s`
- Observe the outputs
- Observe arguments put into registers
- Observe where 'popq' is called.

### Response/Observations

1. The output (result of the addition) is the return value of the add function, so it is saved in `%rax` (because long is quad word, 8 bytes).
2. The arguments of the add function is put into `%rdi` and `%rsi` respectively.
3. `popq` is called at the end of the code for the add function.

# More resources to help

- Matt Godbolt has written a great tool to help understand assembly generated from the compiler. 
  - https://godbolt.org/
- An assembly cheat sheet from Brown
  - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
- MIT Cheat sheet
  - http://6.035.scripts.mit.edu/sp17/x86-64-architecture-guide.html

# Deliverable

- For part 1, add your .S files that you have generated to this repository.
  - Note this submission will be auto graded for completion (i.e. save the file names as shown).
  - Add your observations in the appropriate response/observations section for each code.

# Going Further

- (Optional) Try the objdump example to read the disassembly from your programs executables. Observe how close the output is to the compiler generated output.

